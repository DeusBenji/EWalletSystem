package policy

import (
	"encoding/json"
	"fmt"
	"math/big"
	"os"

	"github.com/consensys/gnark-crypto/ecc/bn254/fr"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr/mimc"
	"github.com/consensys/gnark/frontend"
)

// PolicyCircuit defines the universal policy ZKP circuit.
// Public inputs: challengeHash, policyHash
// Public outputs: subjectCommitment, sessionTag
// Private inputs: walletSecret
type PolicyCircuit struct {
	// Private inputs
	WalletSecret frontend.Variable `gnark:",secret"`

	// Public inputs
	ChallengeHash frontend.Variable `gnark:",public"`
	PolicyHash    frontend.Variable `gnark:",public"`

	// Public outputs (computed by circuit)
	SubjectCommitment frontend.Variable `gnark:",public"`
	SessionTag        frontend.Variable `gnark:",public"`
}

// Define implements the circuit logic.
func (circuit *PolicyCircuit) Define(api frontend.API) error {
	// Note: This is a placeholder circuit definition.
	// The actual circuit is implemented in Circom, not gnark.
	// This Go code only handles proof verification using the verification key
	// generated by snarkjs from the Circom circuit.

	// For gnark verification, we only need the public inputs to match
	// the verification key structure. The circuit logic is already
	// compiled into the verification key.

	return nil
}

const vkeyPath = "/app/circuits/policy_v1_verification_key.json"

// LoadVerifyingKey loads the verification key from file.
func LoadVerifyingKey(path string) error {
	vkFile, err := os.Open(path)
	if err != nil {
		return fmt.Errorf("failed to open verification key: %w", err)
	}
	defer vkFile.Close()

	// Read JSON verification key (exported from snarkjs)
	var vkJSON map[string]interface{}
	if err := json.NewDecoder(vkFile).Decode(&vkJSON); err != nil {
		return fmt.Errorf("failed to decode verification key JSON: %w", err)
	}

	// TODO: Convert snarkjs JSON format to gnark VerifyingKey
	// For now, we'll use a placeholder
	// In production, you need to either:
	// 1. Export vkey in gnark format from circuit compilation
	// 2. Implement snarkjs -> gnark vkey conversion
	// 3. Use a different verification library (e.g., rapidsnark)

	return fmt.Errorf("verification key loading not yet implemented - use rapidsnark or implement snarkjs vkey conversion")
}

// VerifyProof verifies a Groth16 proof for the policy circuit.
// Uses snarkjs via Node.js subprocess for verification.
func VerifyProof(proofBytes []byte, challengeHash, policyHash, subjectCommitment, sessionTag string) (bool, error) {
	// Convert proof bytes to snarkjs JSON format
	proofJSON, err := ConvertProofToSnarkJSFormat(proofBytes)
	if err != nil {
		return false, fmt.Errorf("failed to convert proof: %w", err)
	}

	// Build public signals JSON (order must match circuit)
	publicSignalsJSON, err := BuildPublicSignalsJSON(challengeHash, policyHash, subjectCommitment, sessionTag)
	if err != nil {
		return false, fmt.Errorf("failed to build public signals: %w", err)
	}

	// Verify using snarkjs subprocess
	valid, err := VerifyProofWithSnarkJS(proofJSON, publicSignalsJSON, vkeyPath)
	if err != nil {
		return false, fmt.Errorf("snarkjs verification failed: %w", err)
	}

	return valid, nil
}

// ComputeMiMCHash computes MiMC hash of a single input (for testing/utils).
func ComputeMiMCHash(input *big.Int) *big.Int {
	h := mimc.NewMiMC()
	var e fr.Element
	e.SetBigInt(input)
	b := e.Bytes()
	h.Write(b[:])
	sum := h.Sum(nil)
	return new(big.Int).SetBytes(sum)
}
